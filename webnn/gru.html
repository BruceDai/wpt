<!doctype html>
<meta charset=utf-8>
<title>test gru operation</title>
<link rel="help" href="https://webmachinelearning.github.io/webnn/#api-mlgraphbuilder-gru">
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="https://webmachinelearning.github.io/webnn-polyfill/dist/webnn-polyfill.js"></script>
<div id=log></div>
<script type="module">
  'use strict';
  import * as utils from './utils.js';
  let builder;
  setup(() => {
    const context = navigator.ml.createContext();
    builder = new MLGraphBuilder(context);
  })

  test(() => {
    const steps = 1;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 3;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize)
            .fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array([
          0.3148022,
          -0.4366297,
          -0.9718124,
          1.9853785,
          2.2497437,
          0.6179927,
          -1.257099,
          -1.5698853,
          -0.39671835,
        ]),
    );
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(2));
    const resetAfter = true;
    const layout = 'rzn';
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, resetAfter, layout});
    const graph = builder.build({output: operands[0]});
    const inputs = {'input': new Float32Array([1, 2, 3, 4, 5, 6, 7, 8, 9])};
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      1.9801673183552388,
      1.9812534682811542,
      1.9376592706336329,
      1.9935192730591977,
      1.9947569570033654,
      1.9759958501762682,
      1.997469445392646,
      1.9980404252433588,
      1.9902071255213296,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with 1 steps');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with 2 steps');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const returnSequence = false;
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, returnSequence});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with returnSequence false');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const returnSequence = true;
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, returnSequence});
    const graph = builder.build({output0: operands[0], output1: operands[1]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output0': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
      'output1': new Float32Array(
          utils.sizeOfShape([steps, numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      [
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
      ],
      [
        0.20053661855501925,
        0.20053661855501925,
        0.20053661855501925,
        0.20053661855501925,
        0.20053661855501925,
        0.15482337214048048,
        0.15482337214048048,
        0.15482337214048048,
        0.15482337214048048,
        0.15482337214048048,
        0.07484276504070396,
        0.07484276504070396,
        0.07484276504070396,
        0.07484276504070396,
        0.07484276504070396,
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.22391088955449673,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.16530139937319663,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
        0.0797327116380732,
      ],
    ];
    for (let i = 0; i < expected.length; ++i) {
      assert_array_approx_equals_ulp(outputs[`output${i}`], expected[i], 0);
    }
  }, 'gru with returnSequence true');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const direction = 'forward';
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, direction});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with explict forward direction');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const direction = 'backward';
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, direction});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with backward direction');

  test(() => {
    const steps = 2;
    const numDirections = 2;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const initialHiddenState = builder.constant(
        {type: 'float32', dimensions: [numDirections, batchSize, hiddenSize]},
        new Float32Array(numDirections * batchSize * hiddenSize).fill(0));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const direction = 'both';
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias, initialHiddenState, direction});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.22227008136062426,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.1652493513699554,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
      0.07972921857068853,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru with both direction');

  test(() => {
    const steps = 2;
    const numDirections = 1;
    const batchSize = 3;
    const inputSize = 3;
    const hiddenSize = 5;
    const input = builder.input(
        'input', {type: 'float32', dimensions: [steps, batchSize, inputSize]});
    const weight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, inputSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * inputSize).fill(0.1));
    const recurrentWeight = builder.constant(
        {
          type: 'float32',
          dimensions: [numDirections, 3 * hiddenSize, hiddenSize],
        },
        new Float32Array(numDirections * 3 * hiddenSize * hiddenSize)
            .fill(0.1));
    const bias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0.1));
    const recurrentBias = builder.constant(
        {type: 'float32', dimensions: [numDirections, 3 * hiddenSize]},
        new Float32Array(numDirections * 3 * hiddenSize).fill(0));
    const operands = builder.gru(
        input, weight, recurrentWeight, steps, hiddenSize,
        {bias, recurrentBias});
    const graph = builder.build({output: operands[0]});
    const inputs = {
      'input': new Float32Array(
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]),
    };
    const outputs = {
      'output': new Float32Array(
          utils.sizeOfShape([numDirections, batchSize, hiddenSize])),
    };
    graph.compute(inputs, outputs);
    const expected = [
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.22391088955449673,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.16530139937319663,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
      0.0797327116380732,
    ];
    assert_array_approx_equals_ulp(outputs.output, expected, 0);
  }, 'gru without initialHiddenState');
</script>
